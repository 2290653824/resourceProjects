springboot 2.0

layui

redis

thymeleaf

shiro

第三方登录





资源分享

csdn分享类似



盈利模式：资源丰富 ， 考研资源，学习资源？



技能点：

系统采用主流的springboot2.0框架；前端框架采用流行的Layui；redis高性能缓存框架，存放热门数据，常用数据；thymeleaf模版引擎；shiro安全框架；javamail集成，找回密码用到；数据库连接池使用的是阿里巴巴的Druid；全文检索lucene；登录采用注册的方式的登录和第三方形式QQ登录。





## 项目准备前提

前提：安装redis，设计数据库和表



用户表

资源表

资源类型表

评价表

用户下载表

消息表

友情链接表



![image-20220517205752128](C:\Users\zhengjian\AppData\Roaming\Typora\typora-user-images\image-20220517205752128.png)

我自己设置了一些关系表，因为视频中的关系使用的是外键





## idea

inital springboot

web

springboot dev

thymeleaf

2.5.3





1. 开启热部署,

可以参考我之前写的博客



![image-20220517211719562](C:\Users\zhengjian\AppData\Roaming\Typora\typora-user-images\image-20220517211719562.png)



2. 导入依赖
3. 编写application.yml  dev prod



4. 引入一些静态资源

5. 编写一个thyleaf引擎模板放在resource下的templates中，并手动编写其中的代码。在controller中写一个index请求用户测试进入项目的主界面

6. 编写过滤器filter

   本项目使用的是servlet原生的filter，在前后端分离的项目中有更高级的filter，我记得是WebFilter，它是原生filter的进一步的封装。





FilterRegistrationBean  springboot中自定义过滤器







编写html，用的时layui



区别 dateTImeFormat与JsonFormat的区别





TableField中exist字段的作用





这里我没有进行这个校验 TODO

controller中：[(27条消息) BindingResult总结以及注意事项_啊~~噙！的博客-CSDN博客_bindingresult](https://blog.csdn.net/huluwa10526/article/details/108575922?ops_request_misc=&request_id=&biz_id=102&utm_term=bingResult&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-108575922.142^v10^control,157^v4^control&spm=1018.2226.3001.4187)





在mybatispuls中insertFill配置、作用、使用前提



密码加密



shiro操作 难



关于在传入Controller层时，加入Session等，需要在形参加入HttpSession



在login里必须使用框架（shiro或者springsecurity）进行密码验证，不能使用自己查询数据库进行验证



另外登录成功后，需要将当前用户的信息放到session中。

登录的相关逻辑：先验证传入的用户名密码是否为空，在使用框架验证用户名密码是否正确。（不正确会报错，我们可以对这个报错进行捕获。正确这会返回这个用户对象，我们就可以获取这个用户的相关信息，然后将它保存的session中便于我们后续的使用）









注册逻辑：

在一个表单中填写相应的数据比如用户名、密码、手机、邮箱、昵称等。后端将这些数据保存数据库中（一般这些数据就在同一张表中）

这里密码要使用暗文，即要对密码进行加密后再保存到数据库中。



登录逻辑：

一般使用框架技术，创建一个框架相关的对象，principal设置为username，并把密文密码加入其中，如果存在该用户，则会返回一个用户对象，我们就可以视为登陆成功，并将这个用户对象存到session中，返回Result成功（前后端分离中后端会生成一个token，将token和user相关信息存到redis并设置生存时间。后端会返回一个token，前端将这个taken存到cookie中，以后浏览器访问服务器就会带上这个token，后端接收到token后查询redis对应的用户是否过期，如果过期则重新登录，没有过期则视为登录，并持续使用相应的权限）

```java
 public Map<String ,Object> login(User user, HttpSession session){
		Map<String,Object> map = new HashMap<>();
        if(StringUtil.isEmpty(user.getUsername())){
            map.put("success",false);
            map.put("errorInfo","请输入用户名！");
        }else if(StringUtil.isEmpty(user.getPassword())){
            map.put("success",false);
            map.put("errorInfo","请输入密码！");
        }else{
            Subject subject = SecurityUtils.getSubject();
            UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(),CryptographyUtil.md5(user.getPassword(),CryptographyUtil.SALT));
            try {
                subject.login(token);       //登录验证
                String userName = (String) SecurityUtils.getSubject().getPrincipal();
                User currentUser = userService.findUserByUsername(userName);
                if (currentUser.isOff()) {
                    map.put("success", false);
                    map.put("errorInfo", "该用户已封禁，请联系管理员！");
                    subject.logout();
                } else {
                    currentUser.setLatelyLoginTime(new Date());
                    userService.updateById(currentUser);
                    session.setAttribute(Consts.CURRENT_USER,currentUser);
                    map.put("success", true);
                    map.put("message","登陆成功");
                }
            }catch (Exception e){
                e.printStackTrace();
                map.put("success", false);
                map.put("errorInfo", "用户名或密码错误！");
            }
        }
        return map;


    }

```





找回密码逻辑：

首先前端需要设置一个表项用于记录手机号或者密码，这里我们介绍使用邮箱进行找回密码。

首相我们需要指定一个发送邮箱的账号，如上图所示我们要获取发送邮箱的授权码。

QQ邮箱发送功能：

![image-20220519124130310](D:\Develop\myprojects\resourceProjects\image-20220519124130310.png)





获得授权码：

![image-20220519124338711](D:\Develop\myprojects\resourceProjects\image-20220519124338711.png)

在配置类里面配置MailSender，包括自己的邮箱，授权码，目标邮箱主机地址，SMTP端口。



然后我们在java中进行配置，首先我们要进行配置的是一个邮件发送器`MailSender`，它是一个配置类，用于设置发送邮箱的主机地址端口，发送的授权码，发送用户。具体配置如下：

```java
package com.zj.resourceprojects.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.mail.MailSender;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.JavaMailSenderImpl;

/**
 * qq邮箱配置类
 */
@Configuration
public class MailConfig {

    private static final String USERNAME="2290653824@qq.com";  // 指定发送邮件的账户
    private static final String PASSWORD="gvcddwdfwiadhja";  //指定发送邮箱的授权码

    /**
     * 建议学习一下MailSender是什么
     * @return
     */
    @Bean
    public MailSender mailSender(){
        JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
        mailSender.setHost("smtp.qq.com");  //指定用来发送邮件服务器的主机名
        mailSender.setPort(587);    //默认端口，标准的SMTP端口
        mailSender.setUsername(USERNAME);  //配置自己的qq邮箱
        mailSender.setPassword(PASSWORD);   //配置自己的qq邮箱发送授权码
        return mailSender;
    }

}

```





然后我们就要开始发送验证信息了

前端设置一个表单按钮 发送验证码，用户向后端请求一个发送验证码的请求（请求中带有数据指定邮箱），后端接受到这个请求后，要做两件事：1 生成一个随机的6为数字；2 将这个6位随机数字发送给指定的接受邮箱。

生成一个六位随机数字：

```java
/**
     * 生成六位随机数
     */
    public static String genSixRandom(){
        Random random = new Random();
        String result = "";
        for(int i = 0;i<6;i++){
            result+=random.nextInt(10);
        }
        return result;
    }
```



向指定邮箱发送信息，这里我们需要对这个信息进行封装，并使用前面提到的邮件发送器mailSender将信息进行发送：

```java
package com.zj.resourceprojects.util;

import org.springframework.mail.MailSender;
import org.springframework.mail.SimpleMailMessage;

public class MailUtil {

    //注意这里一定要和Mail配置中的邮箱对应，不然无法成功发送
    public static final String FROM_EMAIL="22903242824@qq.com";

    /**
     * 发送邮件的方法,传入的参数 邮件发送器，目标邮箱，关键验证码信息
     * @param mailSender
     * @param toEmail
     * @param code
     */
    public static void sendMessageToMail(MailSender mailSender,String toEmail, String code){
        SimpleMailMessage message = new SimpleMailMessage();        //消息构造器
        message.setFrom(FROM_EMAIL);                        //发件人
        message.setTo(toEmail);                                       //收件人
        message.setSubject("Java资源分享网-用户找回密码");         //主题
        message.setText("您本次的验证码是：" +code);            //正文内容
        mailSender.send(message);
        System.out.println(code);
    }
}

```



```
String code = StringUtil.genSixRandom();
MailUtil.sendMessageToMail(mailSender,email,code);
//验证码存到session
//其实这里我觉得不应该将验证码存放到session中。像这里的存放方法，MAIL_CODE_NAME不具有全局唯一性，
//当有多个用户进行注册的时候，这里就会被覆盖，而且验证码通常有半个小时过期的特性，这里也没有。
//其实不对，我又想起了，session具有唯一性，一个浏览器与服务器产生一个唯一的session，所以这里MAIL_CODE_NAME,对于
//session来说是唯一的，因为浏览器只能是单用户，所以就不存在并发问题了

//所以，我建议 1.如果坚持使用session，为保证多用户都能够进行操作的前提下，使用id_MAil区分用户(我理解错了)
//2. 使用redis存储验证码的信息 TODO
session.setAttribute(Consts.MAIL_CODE_NAME,code);
session.setAttribute(Consts.USER_ID_NAME,currentUser.getUserId());
```



邮箱发送的逻辑就是这些了，这个方法也就结束了。因为后面还要验证验证码是否正确，我们还需要将验证码code和对应的用户id存到session中，供其他的请求使用信息进行验证。（id是根据目标邮箱查询出来的）



验证邮箱验证码是否正确的id。

此时前端会传过来验证信息和邮箱，我们要做的就是看看session中的验证信息和此输入的验证信息是否相等，如果相等，则表示验证通过。

验证通过后有两种方式1. 此时将用户的密码修改为123456，让用户使用这个简单账号登录系统后再进行修改成自己的密码。2. 让前端返回一个输入两次新密码的界面，让用户输入自己的密码。













